/**
 * Configuration for the final state after all iterations complete.  \
 * Required when `repeat > 0`.
 * @example
 * // Keep last text visible with blinking caret
 * endState: { text: 'typed', caret: 'blink' }
 *
 * @example
 * // Delete last text and hide caret
 * endState: { text: 'deleted', caret: 'hidden' }
 */
export interface EndState {
    /**
     * The final state of the text after all iterations are complete.
     * - 'typed': The last text will remain visible
     * - 'deleted': The last text will be deleted
     */
    text: 'typed' | 'deleted';
    /**
     * The final state of the caret after all iterations are complete.
     * - 'visible': The caret will remain visible
     * - 'hidden': The caret will be hidden
     * - 'blink': The caret will continue blinking indefinitely
     */
    caret: 'visible' | 'hidden' | 'blink';
}
/**
 * Controls caret behavior after text is fully typed and before deletion starts.  \
 * Choose between two modes:
 * 1. Blink mode: Caret blinks n times
 * ```ts
 * afterTyped: { blink: 3 } // Blink 3 times then start deleting
 * ```
 * 2. Wait mode: Pause for n milliseconds
 * ```ts
 * afterTyped: { wait: 150 } // Wait 150 milliseconds then start deleting
 * ```
 * @defaultValue { blink: 2.5 }
 */
export type AfterTyped = {
    /** Milliseconds to wait before deletion starts */
    wait: number;
    blink?: never;
} | {
    /** Number of times to blink before deletion starts */
    blink: number;
    wait?: never;
};
/**
 * Controls caret behavior after text is fully deleted and before typing the next text.  \
 * Choose between two modes:
 * 1. Blink mode: Caret blinks n times
 * ```ts
 * afterDeleted: { blink: 3 } // Blink 3 times then start deleting
 * ```
 * 2. Wait mode: Pause for n milliseconds
 * ```ts
 * afterDeleted: { wait: 150 } // Wait 150 milliseconds then start deleting
 * ```
 * @defaultValue { wait: 150 }
 */
export type AfterDeleted = {
    /** Milliseconds to wait before typing next text */
    wait: number;
    blink?: never;
} | {
    /** Number of times to blink before typing next text */
    blink: number;
    wait?: never;
};
declare class __sveltets_Render<Texts extends readonly string[], Repeat extends number> {
    props(): {
        /**
         * Array of strings to be displayed in sequence.
         */
        texts: Texts;
        /**
         * Number of times to iterate through the texts.
         * - Set to `0` for infinite repetition
         * - Set to a positive number (n) to repeat n times
         * - When set to a positive number, `endState` prop becomes required
         * @defaultValue 0
         */
        repeat?: Repeat | undefined;
        /**
         * Speed of typing animation in milliseconds per character.
         * @defaultValue 60
         */
        typeSpeed?: number;
        /**
         * Speed of deleting animation in milliseconds per character.
         * @defaultValue 40
         */
        deleteSpeed?: number;
        /**
         * Duration of one complete caret blink cycle in milliseconds.
         * @defaultValue 600
         */
        blinkDuration?: number;
        /**
         * Controls caret behavior after text is fully typed and before deletion starts.  \
         * Choose between two modes:
         * 1. Blink mode: Caret blinks n times
         * ```ts
         * afterTyped: { blink: 3 } // Blink 3 times then start deleting
         * ```
         * 2. Wait mode: Pause for n milliseconds
         * ```ts
         * afterTyped: { wait: 150 } // Wait 150 milliseconds then start deleting
         * ```
         * @defaultValue { blink: 2.5 }
         */
        afterTyped?: AfterTyped;
        /**
         * Controls caret behavior after text is fully deleted and before typing the next text.  \
         * Choose between two modes:
         * 1. Blink mode: Caret blinks n times
         * ```ts
         * afterDeleted: { blink: 3 } // Blink 3 times then start deleting
         * ```
         * 2. Wait mode: Pause for n milliseconds
         * ```ts
         * afterDeleted: { wait: 150 } // Wait 150 milliseconds then start deleting
         * ```
         * @defaultValue { wait: 150 }
         */
        afterDeleted?: AfterDeleted;
        /**
         * Callback fired when typing animation begins for each text.
         * @param index - Zero-based index of the text being typed
         */
        ontypestart?: ((index: { [K in keyof Texts]: number extends K ? K & number : K extends `${infer N extends number}` ? N : never; }[number]) => void) | undefined;
        /**
         * Callback fired when typing animation completes for each text.
         * @param index - Zero-based index of the text that was typed
         */
        ontypeend?: ((index: { [K in keyof Texts]: number extends K ? K & number : K extends `${infer N extends number}` ? N : never; }[number]) => void) | undefined;
        /**
         * Callback fired when deletion animation begins for each text.
         * @param index - Zero-based index of the text being deleted
         */
        ondeletestart?: ((index: { [K in keyof Texts]: number extends K ? K & number : K extends `${infer N extends number}` ? N : never; }[number]) => void) | undefined;
        /**
         * Callback fired when deletion animation completes for each text.
         * @param index - Zero-based index of the text that was deleted
         */
        ondeleteend?: ((index: { [K in keyof Texts]: number extends K ? K & number : K extends `${infer N extends number}` ? N : never; }[number]) => void) | undefined;
    } & (0 extends Repeat ? {
        endState?: never;
    } : {
        /**
         * Configuration for the final state after all iterations complete.  \
         * Required when `repeat > 0`.
         * @example
         * // Keep last text visible with blinking caret
         * endState: { text: 'typed', caret: 'blink' }
         *
         * @example
         * // Delete last text and hide caret
         * endState: { text: 'deleted', caret: 'hidden' }
         */
        endState: EndState;
    });
    events(): {};
    slots(): {};
    bindings(): "";
    exports(): {};
}
interface $$IsomorphicComponent {
    new <Texts extends readonly string[], Repeat extends number>(options: import('svelte').ComponentConstructorOptions<ReturnType<__sveltets_Render<Texts, Repeat>['props']>>): import('svelte').SvelteComponent<ReturnType<__sveltets_Render<Texts, Repeat>['props']>, ReturnType<__sveltets_Render<Texts, Repeat>['events']>, ReturnType<__sveltets_Render<Texts, Repeat>['slots']>> & {
        $$bindings?: ReturnType<__sveltets_Render<Texts, Repeat>['bindings']>;
    } & ReturnType<__sveltets_Render<Texts, Repeat>['exports']>;
    <Texts extends readonly string[], Repeat extends number>(internal: unknown, props: ReturnType<__sveltets_Render<Texts, Repeat>['props']> & {}): ReturnType<__sveltets_Render<Texts, Repeat>['exports']>;
    z_$$bindings?: ReturnType<__sveltets_Render<any, any>['bindings']>;
}
/**
 * TypeWriter component for Svelte
 *
 * ### Basic usage
 *
 * ```svelte
 * <TypeWriter texts={['lorem ipsum', 'dolor sit amet']} />
 * ```
 *
 * [Docs](https://github.com/satohshi/svelte-typewriter)
 */
declare const TypeWriter: $$IsomorphicComponent;
type TypeWriter<Texts extends readonly string[], Repeat extends number> = InstanceType<typeof TypeWriter<Texts, Repeat>>;
export default TypeWriter;
